TMUX
https://www.youtube.com/watch?v=nTqu6w2wc68
Was an der Pruefung kommt.

Sharefolder einrichten: pin=2710
Werden Sharefolder aur Pruefungsabgabe nutzen!

Pruefungstoff: was auf dem Cheatsheet der Lektion 8 zusammengefasst ist.
Und insbesondere Aufgaben, die wir heute anschauen.


Stringmanipulationen:

# 1
s = 'halxlo'
i = s.index('x')
s[:i] + s[i+1:]


# 2
s = 'abcdefgh'
s[::-1]

# 3
s = 'abcdefgh'
i = 3

sx = s[:i] + 'x' + s[i:]
print(sx, sx[3])

# 4a
words = ['foo', 'bar', 'baz']
', '.join(words)

# 4b
words = ['foo', 'bar', 'baz']

s = ''
for word in words:
    s = s + word + ', '

s[:-2]


def find_palindroms(words):
    '''gib eine Liste mit den Woertern in words
       zurueck, die Palindrome sind.
       Unterscheide nicht zw. Gross- und Kleinbuchstaben
    '''
    return [w for w in words if w.lower() == w.lower()[::-1]]


def one_space_breaks(s):
    '''entferne Whitespace am Anfang und Ende und
       reduziere Whitespace zw. Woertern zu ' '
    '''
    parts = s.split()
    return ' '.join(parts)


Sortieren von Listen und Dicts:

# 1
sorted(words)

# 2
sorted(words, key=lambda x: x.upper())

# 3
sorted(words, key=lambda x: (x.upper(), x))

# 4
sorted(words, key=lambda x: (len(x), x.upper(), x))

# 5 Hilfsfunktion
def distance(v, w):
    dist = ((w[0]-v[0])**2 + (w[1] - v[1])**2)**(1/2)
    return dist

# 5 Hilfsfunktion testen
ursprung = (0, 0)
for pt in points:
    print(f'Abstand vom Ursprung: {distance(ursprung, pt)}')

# 5
[round(distance(ursprung, pt), 2) for pt in points]

# 6
ursprung = (0, 0)
sorted(points, key=lambda pt: distance(ursprung, pt))

# 7
d = dict(zip(words, words_en))
d

# 8
kv_pairs = sorted(d.items(), key=lambda x: x[1])
dict(kv_pairs)

# 9
kv_pairs = sorted(d.items(), key=lambda x: (x[0].upper(), x))
dict(kv_pairs)
--------------------------------------------------

For-Schleifen:

def minimum(xs):
    '''gib die kleinste Zahl der Liste xs zurueck
       ohne die Funktion min zu benutzen.
    '''
    m = xs[0]
    for x in xs[1:]:
        if x < m:
            m = x
    return m

def product(xs):
    '''berechne das Produkt aller Zahlen in der Liste xs'''
    product = 1
    for x in xs:
        product = product * x
    return product

While-Schleifen:

# Menge
numbers = set()

while len(numbers) < 5:
    number = randint(0, 9)
    numbers.add(number)

numbers

# Liste
numbers = []

while len(numbers) < 5:
    number = randint(1, 9)
    if number not in numbers:
        numbers.append(number)

numbers

# Tuple
numbers = ()

while len(numbers) < 5:
    number = randint(1, 9)
    if number not in numbers:
        numbers = numbers + (number,)

numbers

---------------------

Count-dict

# 1
d = {}
ziffern = '0123456789'

while 3 not in d.values():
    answer = input('Ziffer:')
    if len(answer) == 1 and answer in ziffern:
        d[answer] = d.get(answer, 0) + 1

d


# 2
for k, v in d.items():
    if v == 3:
        print(f'Die Ziffer {k} wurde 3 Mal eingegeben.')
        break

# 3
sum(d.values())

# 4
total = 0
for v in d.values():
    total = total + v

total

# 5
total = 0
for k, v in d.items():
    total = total + int(k)*v

print('Durchschnitt:', total/len(d))

-------------------------------------


File oeffnen, Dicts: Einkaeufe

# 1a
for pid, (product, price) in pid_prodPrice.items():
    print(f'Produkt-ID: {pid}, Produktname: {product}, Preis: {price}')

# 2
filename = 'Einkaeufe.txt'
with open(filename, mode='r') as f:
    lines = [line.rstrip() for line in f]

lines

# 3
line = lines[1]
fields = line.split(',')
fields

# 3 cont.
cid = int(fields[0])
pids = tuple(int(n) for n in fields[1:])
cid, pids

# 3 cont.
products = [pid_prodPrice[pid][0] for pid in set(pids)]
products.sort()
products

# 4
cid_pids = {}
for line in lines[1:]:
    fields = line.split(',')
    cid = int(fields[0])
    pids = tuple(int(n) for n in fields[1:])
    cid_pids[cid] = pids

cid_pids

# 5
cid_products = {}
for cid, orders in cid_pids.items():
    products = set(pid_prodPrice[n][0] for n in orders)
    cid_products[cid] = sorted(products)

cid_products

# 6 cid_SummeDerPreise
cid_total = {}
for cid, pids in cid_pids.items():
    prices = [pid_prodPrice[pid][1] for pid in pids]
    total = sum(prices)
    cid_total[cid] = total

cid_total

# 6 dict sortieren
dict(sorted(cid_total.items(), key=lambda x: x[1], reverse=True))


Pokerhaende

# Deck mit allen 52 Karten
deck = [rank+suit for suit in SUITS for rank in RANKS]
deck[:3] + deck[-3:]

# zufaellige Karte
n = len(deck)
i = randint(0, n-1)
card = deck[i]
card

# zufaellige Hand
hand = set()
n = len(deck)

while len(hand) < 5:
    i = randint(0, n-1)
    card = deck[i]
    hand.add(card)

tuple(hand)


def get_hand(ncards=5):
    hand = set()
    n = len(deck)

    while len(hand) < ncards:
        i = randint(1, n)
        card = deck[i-1]
        hand.add(card)

    return tuple(hand)

# Ranks
hand = ('J♥', 'Q♣', '7♠', '6♣', 'Q♦')
ranks = [card[0] for card in hand]
ranks

# RANK_IDX dict
RANK_IDX = {rank: i for i, rank in enumerate(RANKS)}
RANK_IDX

ranks_sorted = sorted(ranks, key=lambda x: RANK_IDX[x])
ranks_sorted

# als String
''.join(ranks_sorted)


def get_ranks_sorted(hand):
    ranks = [card[0] for card in hand]
    ranks_sorted = sorted(ranks, key=lambda x: RANK_IDX[x])
    return ''.join(ranks_sorted)

hand = ('K♦', '6♦', 'A♦', '8♥', 'Q♠')
ranks = get_ranks_sorted(hand)
# suits = ''.join(card[1] for card in hand)
# print(f'hand {hand}, ranks: {ranks}, suits: {suits}')
print(f'hand {hand}, ranks: {ranks}')


# 1
def is_flush(hand):
    suits = set(card[1] for card in hand)
    return len(suits) == 1


def is_straight(hand):
    ranks = get_ranks_sorted(hand)
    return ranks == '2345A' or ranks in RANKS

hands = [('A♠', '2♣', '3♦', '4♥', '5♦'),
         ('6♥', '7♥', '8♦', '9♣', 'T♣'),
         ('T♥', '7♥', '3♥', 'A♥', 'Q♥'),
         ('T♥', 'J♥', 'J♣', 'T♦', 'J♠'),
         ('K♦', '6♦', 'A♦', '8♥', 'Q♠'),
         ]

for hand in hands:
    print(f'Hand: {hand}, Flush: {is_flush(hand)}, Straight: {is_straight(hand)}')


def make_count_dict(items):
    d = {}
    for item in items:
        d[item] = d.get(item, 0) + 1
    return d


# 2
def is_fullhouse(hand):
    ranks = get_ranks_sorted(hand)
    d = make_count_dict(ranks)
    return len(d) == 2 and 3 in d.values()


for hand in hands:
    print(f'Hand: {hand}, Fullhouse: {is_fullhouse(hand)}')

# 3
hand_name = {}
for hand in hands:
    if is_flush(hand):
        hand_name[hand] = 'flush'
    elif is_straight(hand):
        hand_name[hand] = 'straight'
    elif is_fullhouse(hand):
        hand_name[hand] = 'fullhouse'
    else:
        hand_name[hand] = 'nothing'

hand_name

# 4
N = 10_000

n_straight = 0
n_flush = 0
n_fullhouse = 0

for _ in range(N):
    hand = get_hand()

    if is_straight(hand):
        n_straight = n_straight + 1
    if is_flush(hand):
        n_flush = n_flush + 1
    if is_fullhouse(hand):
        n_fullhouse = n_fullhouse + 1

print(f'straights: {n_straight}, flushes: {n_flush}, fullhouses: {n_fullhouse}')