Recap_03 15'
Module   15'
if-then-else aus Lektion 03: 30'
Variabeln Objekte Referenzen 30'
Pause 15'
Lists 30'
Indexing and Slicing 30'
Bubble-Sort 30'
-----------------
Dinge, die Leben einfacher machen: if else, und Index und Slicenotaton.
neu Listen: mutable (veraenderbarer Typ) (ansonst wie Tuple)

Task: modules/my_functions.py mit test() und Funktionen aus Loesungen_03/Funktionen_schreiben.
Recap_03: Tuples, f-Strings und '''-Strings und !Funktionen!
  Tuples: recall, how with words, show it
  Erstelle File my_functions.py, zeige wie aus Loesungen_02.ipynb kopiere,
  schreibe Funktion test, wenn funktioniert, fuege hinzu.

15'


Task: fun4.py mit randint 
add: from random import randint
Module.ipynb: module (-> Zufallstupel)
  - Vorteil von import foo: Autocompletion!
20'

if-then-else aus Lektion 03: 30'

Zeige zuerst folgendes:
x = 10
if x % 2 == 0:
    print(f'{x} ist gerade')
if x % 2 != 0:
    print(f'{x} ist ungerade')


neu:
x = 10
if x % 2 == 0:
    print(f'{x} ist gerade')
else:
    print(f'{x} ist ungerade')

# Abhandeln von sich gegenseitig ausschliessenden Faellen

x = 'abc'

if type(x) is float:
    print(f'{x} ist Float')
elif type(x) is int:
    print(f'{x} ist Integer')
elif type(x) is str:
    print(f'{x} ist String')
else:
    print(f'{x} ist kein Float, Integer oder String')

Tasks: sign und fizzbuzz, fizzbuzz testen!
if-the_else aus L03: 30'
  fizzbuzz: teste 3 und 5 zuerst, dann if nur 3, if nur 5

Diskutiere Teststrategie!
Bleibe in Schleife, solange noch Werte zum Testen, und solange Antwort richtig!

values = ...
i = 0 
n = len(values)
while i < n and fizzbuzz(i+1) == values[i]:
    ...
    i = i + 1

====
Pause 10' 
====

pre Listen: erster mutable (modifizierbarer) Typ.
    Listen sind ansonsten wie Tuple, werden aber mit eckigen Klammern
    [1, 2, 3] erstellt.

xs = [2, 1, 'foo']
xs

xs[2] = 3
xs

# sortiere: muss die ersten beiden Elemente vertauschen!

tmp = xs[0]
xs[0] = xs[1]
xs

xs[1] = tmp
xs

!!!WICHTIG!!! werde fuer die nachsten 30 auf diesem Punkt herumhacken!

ys = xs
xs is ys

ys[0] = 'new'
xs

xs is ys

Tasks: Pythontutor.
-> Variabeln Objekte Referenzen 30'
- Beginne mit Bild!
- Dann, Objekte im speicher koennen unerreichbar werden
- += bei Strings und Listen
- identische und gleiche Objekte
- Visualisierung mit Pythontutor
- Garbage Colletion


Listen: (mit Listen kann man noch viel mehr machen, als hier gezeigt.
         wollen uns aber fuer den Moment auf das hier Eingefuehrte beschraenken)
       
Alle Typen, int, float, str, bool, tuple, None, die wir bis jetzt kennengelernt haben sind
immutable (nicht modifizierbar).

Unpraktisch, teuer.

das Beispiel: etwas Zahlen!


Beispiel:
Listenelement kann etwas zaehlen, oder Kontostaende speichern, die staendig andern,
Punkte eines Bildes oder Videos, ...

Elemente selber koennen aendern, aber auch die Liste selbst kann
laenger (+=) oder kuerzer werden (mehr dazu spaeter, im Moment nur +=).


Aufgaben 1: very simple: +=, +, Listenelement Wert zuweisen
Aufgaben2: Zufallszahlen zaehlen. get_rundom_numbers
Bespreche dies, diskutiere unterschied zu get_random_digits. (dort jedesmal neues Tupel erzeugt)

Nun zu Indexing und Slicing!
s = '0123456789'
s[0]
s[-1]

# s[start:stop:step]

s[:3]
s[-3:]

s[1:3]

s[1:20]  # kein IndexError!

s[20:0]
s[20:0:-1]
s[10:0]
s[::-1]

Task: 
   Zeichen in String einfuegen bez loeschen!
   Testen, ob Wort auf ung endet

Indexing and Slicing. 20'
ev. ueberspringe updaten mit Slicing!

Listen Aufgaben 3.
Nun zu Bubble-Sort und Listen Aufgaben 3.

Schon gesehen, dass es fuer Anwendungen wie suchen von grossem Vorteil ist,
falls Liste sortiert.
Listen kann man in place sortieren.
Muss keine neue liste erstellen, nur Listenelemente tauschen.

Werden ersten Sortieralgo anschauen, Bubble-Sort.

Ziel: erste Version von Bubble-Sort,
      schreiben dann eine Variante die doppelt so schnell ist.

      Was sind die elementaren Schritte beim Sortierprozess? Swaps (nur Elemente vertauschen)

Sell this as Bubble-Sort.
Grundoperations zum Sortieren: 
Swap (Listenelemente tauschen!)
Diskuss how to Sort with Swaps.
Tausche aufeinanderfolgende Elemente, falls linkes groesser als rechtes.
Tun wir das fuer aller benachbarten Elemente, so wird das groesste Element ganz nach rechts gebracht.

[4, 3, 2, 1]
[4, 3, 2, 1]
[4, 3, 2, 1]
[4, 3, 2, 1]

[4, 3, 2, 1]
[3, 4, 2, 1]
[3, 2, 4, 1]
[3, 2, 1, 4]

[2, 3, 1, 4]
[2, 1, 3, 4]


[1, 2, 3, 4]

Task: simple bubble sort in fun4
Loese Listen Aufgaben 3:
 is_sorted(items)

sortiert, falls fuer alle 0<=i<len(items), items[i] <= items[i+1]
unsortiert falls fuer ein i, items[i] > items[i+1]
kann mit return aus While-Schleife ausbrechen.

def f():
    while True:
        return 'done'


Blick auf loesungen. Was koennte verbessert werden?
Bubble up bubbled immer ganze Liste, obwohl nur fuer Anfangsabschnitt noetig!

Bubble sort
20'



=======fun4.py=======

from random import randint


PI = 3.1415926535


def test():
    '''gibt PI aus'''
    print(f'PI ist {PI}')


def get_random_digits(n):
    '''n: int
       gibt ein Tuple mit n zufaelligen Ziffern zurueck
    '''
    digits = ()
    i = 0
    while i < n:
        x = randint(0, 9)
        digits = digits + (x,)
        i = i + 1
    return digits


def get_random_numbers(n):
    '''n: int
       gibt eine Liste mit n Zufallszahlen zw. 1 und 10*n zurueck
    '''
    numbers = [0] * n
    i = 0
    while i < n:
        numbers[i] = randint(1, 10*n)
        i = i + 1
    return numbers


def swap_items(items, i, j):
    '''items: list
       vertauscht items[i] und items[j]
    '''
    tmp = items[i]
    items[i] = items[j]
    items[j] = tmp


def bubble_at(items, i):
    '''items: list (mit vergleichbaren Elementen)
       i: int
       vertausche items[i] und items[j], falls items[i] > items[j]
    '''
    if items[i] > items[i+1]:
        swap_items(items, i, i+1)


def bubble_up(items):
    '''items: list (mit vergleichbaren Elementen)
       vertausche von links nach rechts benachbarte Elemente,
       falls das linke groesser ist als das rechte.
    '''
    n = len(items)
    j = 0
    while j < n-1:
        bubble_at(items, j)
        j = j + 1


def bubble_sort(items):
    '''items: list (mit vergleichbaren Elementen)
       sortiert items aufsteigend
    '''
    n = len(items) - 1
    i = 0
    while i < n:
        bubble_up(items, i)
        i = i + 1


def is_sorted(items):
    '''items: list (mit vergleichbaren Elementen)
       gibt True zurueck falls die items sortiert ist, sonst False
    '''
    n = len(items)
    i = 0
    while i < n-1:
        if items[i] > items[i+1]:
            return False
        i = i + 1
    return True


def count_digits(digits):
    '''digits: str
       gibt eine Liste counts der Laenge 10 zurueck, wobei counts[i] angibt,
       wie oft die Ziffer i im String digits vorkommt
    '''
    counts = [0] * 10
    i = 0
    while i < len(digits):
        idx = int(digits[i])
        counts[idx] = counts[idx] + 1
        i = i + 1
    return counts


=========

def update_tuple(items, i, val):
    '''items: tuple
       i: int 
       gibt ein tuple zurueck, wo items[i] = val
    '''
    res = ()  
    j = 0
    while j < len(items):
        if i == j:
            res = res + (val,)
        else:
            res = res + (items[j],)
        j = j + 1
    return res