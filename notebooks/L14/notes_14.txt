Projektskizzen:
Tobias M: leer
Thomas: Hangman. tastatur zuerst via Maus. Werden alle Buchstaben aufgedeckt?
                 Ask AI fuer grosse Wotliste, wv. geornet nach Thema.

Pruefungsextras Patrick? Test Fehlen, sonst alles ok?

class Schach:

    SPACE = ' '

    def __init__(self):
        self.board = [[' ' for _ in range(8)] for _ in range(8)]
        self.ptm = 0

Game wie Snake:
Erste Version nicht dynamisch, snake bewegt sich nur falls Pfeiltaste gedrueckt wird,
ebenso  bei Pong!


Einsteigen mit Schach_I.ipynb

Neues Notebook: Diskuss schach_1.py
import schach_1 as schach

schach.board

schach.new_game()
schach.board

schach.raw_move((3, 6), (3, 4))
schach.board

Dann schach_D0.py
und Rest von Schach_I.ipynb

Dann Schach_II.ipynb, Schach_II_A.ipynb

Dann L14/Schach/schach_2.py

Schreibe schach als Klasse: live, show Debugging
Aenderungen in Schach.ipynb: nur diese 2 Zeilen!
from schach_als_Klasse import Schach
# import schach
schach = Schach()


Darstellung als Klasse:

# import schach
from schach_als_Klasse import Schach
# import schach_D as D
from schach_D_als_Klasse import View
import helpers as H
# from ipycanvas import MultiCanvas
# from ipywidgets import Output, Button
from ipywidgets import Output
from IPython.display import display


schach = Schach()
view = View()

# state = {'mouse_down': None}

layout = {'border': '1px solid black'}
out = Output(layout=layout)
# button = Button(description='New Game')
# mcanvas = MultiCanvas(2, width=200, height=200, layout=layout)
# bg, fg = mcanvas


@out.capture(clear_output=True)
def on_mouse_down(x, y):
    # state['mouse_down'] = (x, y)
    view.mouse_down = (x, y)
    # print(f'state[\'mouse_down\'] set to ({int(x)}, {int(y)})')
    print(f'view.mouse_down set to ({int(x)}, {int(y)})')


@out.capture()
def on_mouse_up(x, y):
    # target = H.xy2cr(x, y, D.BOARD_SPEC)
    target = H.xy2cr(x, y, view.BOARD_SPEC)
    # src = H.xy2cr(*state['mouse_down'], D.BOARD_SPEC)
    src = H.xy2cr(*view.mouse_down, view.BOARD_SPEC)

    schach.raw_move(src, target)
    print(f'move from {src} to {target}')


# D.draw_chessboard(bg)
view.draw_chessboard(view.bg)

# schach.update = lambda event, **kwargs: D.update(fg, event, **kwargs)
schach.update = lambda event, **kwargs: view.update(view.fg, event, **kwargs)
schach.new_game()

# mcanvas.on_mouse_down(on_mouse_down)
view.mcanvas.on_mouse_down(on_mouse_down)
# mcanvas.on_mouse_up(on_mouse_up)
view.mcanvas.on_mouse_up(on_mouse_up)

# button = Button(description='New Game')
# button.on_click(lambda _: schach.new_game())  # Argument ignorieren
view.button.on_click(lambda _: schach.new_game())

# display(mcanvas, button, out)
display(view, out)


========================
Klassen
Thread und Eventloop (nur kurz diskutiere ausfuehlicher, mit Leuten, die diese brauchen)



button_new_game = Button(description='New Game')

@out.capture()
def new_game():
    canvas.clear()
    stop_event.clear()
    event_queue.clear()
    event_queue.insert(0, 'Right')
    event_loop()
    canvas.focus()


canvas.on_key_down(on_key_down)
button_stop.on_click(lambda bt: stop_event.set())
button_new_game.on_click(lambda bt: new_game())

display(canvas, button_stop, button_new_game, out)
canvas.focus()  # Canvas Widget hoert auf Events, ohne das se zuerst angeklickt werden muss