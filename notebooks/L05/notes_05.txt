def scalarproduct(v, w):
    '''berechne das Skalarprodukt 2er 2-dim Vektoren'''
    return v[0]*w[0] + v[1]*w[1]


!Loesungen_04.ipynb! nochmals, Korrektur, for-Schleif statt While-Scheile
bring in with extras: split.py persons.txt 


Tuple unpacking
zeige Fehlermeldungen ValueError: 
 - too many values to unpack (expected 3)
 - ValueError: not enough values to unpack (expected 3, got 2)

Discuss:

word = 'Vorbereitung'
prefix = 'Vor'
suffix = 'ung'
word[:len(prefix)] == prefix
word[-len(suffix):] == suffix

Uebung:
s = '0123456789'


s[:2], s[2:]
s[:2], s[2+1:]
s[:2] + s[2+3:]



s[:2] + '234' + s[2:]

same mit Tuple 
====
s = tuple('0123456789')
...
=====

def delete(s, i, n):
    t = ...
    return t

def insert(s, i, t):
    res = ...
    return res
    
10' in Raeume.
show
def delete(s, i, n):
    return s[:i] + s[i+n:]


def insert(s, i, t):
    return s[:i] + t + s[i:]

=======================================
String splitten: allg. Vorgehen. Zuerst von Hand, dann mit Hilfsfunktionen.
Zusammen: Greifen Namen heraus.

Zeige Variante 1 (geht nicht nimmer!)
Erstes Vorkommen von Komma finden.
# Fix it:
n = len(text)
i = 0
while i < n and text[i] != SEP:
    ...
print(f'Erstes Vorkommen von "{SEP}" oder LÃ¤nge von {text}: {i}')
als Funktion

10' in Raeume.

oder 
text = text + SEP
--
def get_idx(s, sep):
    '''s: String
       gibt den Index des Zeichen sep in s zurueck, oder len(s)
    '''
    i = 0
    n = len(s)
    while i < n and s[i] != sep:
        i = i + 1
    return i

# teste mit
get_idx('Anna', ',')


Das selbe, nun Anfang von String finden:

10' Raeume:


def get_start(s):
    '''s: str
       gib Index des 1. non-SPACE zeichen zurueck, oder len(s)
    '''
    SPACE = ' '
    n = len(s)
    i = 0
    while i < n and s[i] == SPACE:
        i = i + 1
    return i

names = '  Anna, Bob, Carl,'
get_start(names)

--alt--
def get_start(s):
    '''s: str
       gib Index des 1. non-SPACE zeichen zurueck, oder len(s)
    '''

    SPACE = ' '
    n = len(s)
    if s == ' ' * len(s):
        return n

    i = 0
    while s[i] == SPACE:
        i = i + 1
    return i

------------
Head-Tail und split
Erklaere Idee:
1. stelle benoetige Hilffunktionen bereit,
   implementiere While-Schleife, die oben im Text beschrieben ist.

Raeume 15'

start = get_start(names)
stop = get_idx(names, SEP)

name = names[start:stop]
line = names[stop+1:]
print(f'Name: {name}, new names: "{names}"')

def get_head_tail(s, sep):
    '''s: String
       gibt ein Tuple (head, tail) zurueck
       head: Teil vom ersten non-SPACE Zeichen bis zum Komma
       tail: Teil nach dem Komma
    '''
    start = get_start(s)
    stop = get_idx(s, sep)

    head = s[start:stop]
    tail = s[stop+1:]
    return head, tail


names = '  Anna, Bob, Carl'
SEP = ','
get_head_tail(names, SEP)

def split(s, sep):
    '''s: str (kommaseparierte Werte)
       gibt ein Tupel mit den Werten zurueck
    '''
    values = ()
    while s:
        value, s = get_head_tail(s, sep)
        values = values + (value,)
    return values

names = '  Anna, Bob, Carl'
SEP = ','
split(names, SEP)

speichere alle Funktione in einem File split.py

==================

Intermezzo: Nochmals zu Index- und Slicenotation: (mit While, nicht For)
            Lasse Aufgabe loesen.
word = 'Achtung'
word[-3:]  # die letzten 3 Buchstaben von word
word[-3:] == 'ung'  # endet word mit 'ung'

def select(items, suffix):#  Upps, wir haben noch keine For-Schleifen!
    n = len(suffix)
    result = []
    for item in items:
        if item[-n:] == suffix:
            result = result + [item]
    return result


================================

Anwendung: update -e
Note: got split_a_string_Loesung.ipynb, split.py and persons.txt (3 Files)

Aufgabe:

wie testen, ob Email auf .net endet?
wie die letzten 4 Zeichen der Email ausgeben?

persons_net = ()
n = len(persons)

i = 0
while i < n:
    person = persons[i]
    email = person[2]
    if email[-4:] == '.net':
        persons_net = persons_net + (person,)
    i = i + 1

persons_net

Vorbereitung get_items
Ausgabe:

s = '0123456789'
indices = (2, 3, 6)


n = len(indices)
i = 0
while i < n:
    idx = indices[i]
    print(s[idx])
    i = i + 1

In Tuple speichern:
s = '0123456789'
indices = (2, 3, 6)

result = ()
n = len(indices)
i = 0
while i < n:
    idx = indices[i]
    result = result + (s[idx],)
    i = i + 1
result

Listen: Revisited
pre Listen: erster mutable (modifizierbarer) Typ.
    Listen sind ansonsten wie Tuple, werden aber mit eckigen Klammern
    [1, 2, 3] erstellt.

xs = [2, 1, 'foo']
xs

xs[2] = 3
xs

# sortiere: muss die ersten beiden Elemente vertauschen!

tmp = xs[0]
xs[0] = xs[1]
xs

xs[1] = tmp
xs

swap
xs[0], xs[1] = xs[1], xs[0]

Liste verlaengern.
xs = [1, 2]
xs+= [2,3]
xs


[0] * 5  # Liste mit 0 initialisieren

Aufgabe 3 Listen: Typo in Aufgabe 3: 'mit' -> '>'

xs = [6, 4, 3, 1, 2]xs = [6, 3, 5, 2, 1]

xs[0], x[-1] = xs[-1], xs[0]  # erstes mit letztem vertauschen


def swap(items, i, j):
    items[i], items[j] = items[j], items[i]


def bubble_at(items, i):
    if items[i] > items[i+1]:
        swap(items, i, i+1)


def bubble_up(items):
    i = 0
    while i < len(items)-1:
        bubble_at(items, i)
        i = i + 1

# beim i-ten Aufruf, muss nur noch items[:-i] sortieren.

bubble_up(xs)
xs

def bubble_sort(items):
    i = 0
    while i < len(items)-1:
        bubble_up(items)
        i = i + 1


xs = [6, 3, 5, 2, 1]

bubble_sort(xs)
xs
====

def is_sorted(items):
    ...



xs = [1, 3, 5, 4]

n = len(xs)
i = 0
while i < n-1:
    if xs[i] > xs[i+1]:
        print(i, 'not sorted')
    i = i + 1







Stringmethoden.ipynb